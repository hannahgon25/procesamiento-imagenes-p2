<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Reporte Segundo Parcial - Procesamiento de Im√°genes</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>üìã Reporte Segundo Parcial</h1>
    <h2>Procesamiento de Im√°genes</h2>
    <p>Equipo: Panteras Verdes xD</p>
    
    <!-- Apartado desplegable -->
    <details>
      <summary><b>Integrantes</b></summary>
      <ul>
        <li>Gonz√°lez Garc√≠a Hannah Andrea - ID:0276927</li>
        <li>Reza Zatarain Jes√∫s Miguel - ID:0276971</li>
        <li>Guti√©rrez Castellanos Carol Kristel - ID:0276969</li>
      </ul>
    </details>
  </header>
  
  <nav>
    <ul>
      <li><a href="#tema1">1. [Tema 1]</a></li>
      <li><a href="#tema2">2. Procesamiento Digital de Im√°genes</a></li>
      <li><a href="#tema3">3. [Fundamentos, Filtrado y Morfolog√≠a Matem√°tica]</a></li>
      <li><a href="#abstract">4. Abstract (English)</a></li>
      <li><a href="#conclusiones">5. Conclusiones</a></li>
    </ul>
  </nav>

  <main>
    <!-- TEMA 1 -->
    <section id="tema1">
      <h2>1. [Tema 1 (Hannah)]</h2>
      <p>
        [Contenido del tema 1]
      </p>
    </section>

    <!-- TEMA 2 -->
    <section id="tema2">
      <h2>2. Procesamiento Digital de Im√°genes (Miguel)</h2>
      <p>
        En esta secci√≥n se abordaron los fundamentos del procesamiento digital de im√°genes (PDI), comenzando con la adquisici√≥n y digitalizaci√≥n de im√°genes, donde se explic√≥ c√≥mo una imagen anal√≥gica se convierte en formato digital mediante sensores que capturan la informaci√≥n luminosa y la transforman en una matriz num√©rica. Se revisaron los conceptos de muestreo espacial y de intensidad, esenciales para representar correctamente los detalles de la imagen.
      </p>
      <p>
        Posteriormente, se analiz√≥ la representaci√≥n y almacenamiento de im√°genes, entendiendo que cada imagen se compone de una matriz de p√≠xeles cuyos valores determinan su intensidad o color. Se discuti√≥ la importancia de la resoluci√≥n, la profundidad de bits y los formatos m√°s comunes como BMP, PNG y JPG, destacando sus ventajas seg√∫n el uso y el nivel de compresi√≥n requerido.
      </p>
      <p>
        En cuanto a las operaciones puntuales y de contraste, se exploraron t√©cnicas que modifican directamente la intensidad de los p√≠xeles, tales como la ecualizaci√≥n de histograma, el ajuste de brillo y contraste, y la normalizaci√≥n, las cuales permiten mejorar la apariencia visual o resaltar detalles relevantes de la imagen.
      </p>
      <p>
        Tambi√©n se presentaron los filtros espaciales y la convoluci√≥n, herramientas esenciales para el procesamiento local de p√≠xeles. Se revisaron filtros lineales (como el promedio y el gaussiano) y no lineales (como el de mediana), aplicados al suavizado, la detecci√≥n de bordes y la eliminaci√≥n de ruido. Adem√°s, se explic√≥ el papel de las m√°scaras y el operador de convoluci√≥n en la manipulaci√≥n de la imagen.
      </p>
      <p>
        En el tema de transformaciones geom√©tricas, se describieron procesos como la traslaci√≥n, rotaci√≥n y escalado de im√°genes, los cuales modifican la posici√≥n y orientaci√≥n de los p√≠xeles mediante coordenadas homog√©neas y transformaciones matriciales.
      </p>
      <p>
        M√°s adelante, se abord√≥ la segmentaci√≥n y el an√°lisis morfol√≥gico, que incluyen m√©todos para dividir una imagen en regiones significativas utilizando t√©cnicas de umbralizaci√≥n, detecci√≥n de contornos y operaciones morfol√≥gicas como la dilataci√≥n, erosi√≥n, apertura y cierre, √∫tiles en el reconocimiento de objetos y an√°lisis estructural.
      </p>
      <p>
        Finalmente, se exploraron diversas aplicaciones del PDI, mostrando c√≥mo estos conceptos se emplean en √°reas como la visi√≥n por computadora, el an√°lisis m√©dico y los sistemas de seguridad, demostrando el impacto y la versatilidad del procesamiento digital de im√°genes en la actualidad.
      </p>
    </section>

    <!-- TEMA 3 -->
    <section id="tema3">
      <h2>3. Fundamentos, Filtrado y Morfolog√≠a Matem√°tica (Carol)</h2>
      <p>


  <h3>I. Fundamentos, Configuraci√≥n y Manipulaci√≥n Num√©rica</h3>

  <p>
   
  <h3>3. Filtrado y Detecci√≥n de Bordes en PDI</h3>
  <p>
    Esta secci√≥n cubre las t√©cnicas esenciales de manipulaci√≥n de vecindades (filtrado)
    utilizadas para suavizar im√°genes, eliminar ruido y resaltar contornos.
  </p>

  <h3>3.1. M√°scaras (Kernels o Elementos Estructurantes)</h3>
  <p>
    Una <strong>m√°scara (kernel)</strong> es una matriz peque√±a que define la vecindad de p√≠xeles
    que influir√° en el valor del p√≠xel central. La disposici√≥n y los valores de sus elementos
    determinan la operaci√≥n de filtrado (suavizado, detecci√≥n de bordes, etc.).
  </p>
  <p>
    <strong>Funcionamiento:</strong> Se definen como arrays de NumPy con el tipo de dato adecuado
    (t√≠picamente <code>np.float32</code>) para convoluci√≥n. Los valores internos representan
    los pesos aplicados a los p√≠xeles vecinos.
  </p>
  <pre><code class="language-python">
# Kernel para Filtro Promedio (caja 3x3 sin normalizar)
kernel_caja = np.ones((3, 3), np.float32)

# Kernel para Filtro Laplaciano (ejemplo de 4-vecinos)
kernel_laplaciano = np.array([[ 0,  1,  0],
                              [ 1, -4,  1],
                              [ 0,  1,  0]], dtype=np.float32)
  </code></pre>

  <h3>3.2. Convoluci√≥n y Correlaci√≥n</h3>
  <p>
    La <strong>convoluci√≥n</strong> es la operaci√≥n fundamental del filtrado lineal.
    Implica voltear la m√°scara 180¬∞ y calcular la suma ponderada del producto del kernel
    con los p√≠xeles de la vecindad. En la pr√°ctica, OpenCV utiliza la correlaci√≥n (equivalente
    si el kernel es sim√©trico) mediante la funci√≥n <code>cv.filter2D()</code>.
  </p>
  <pre><code class="language-python">
# Se asume que 'kernel_normalizado' ya est√° definido (ej. kernel_caja / 9)
apple_filtrada = cv.filter2D(apple, -1, kernel_normalizado)
  </code></pre>

  <h3>3.3. Filtro Promedio (Filtro de Caja)</h3>
  <p>
    Es un filtro de paso bajo que realiza la operaci√≥n de suavizado.
    Su principal efecto es la atenuaci√≥n del ruido de alta frecuencia y el detalle fino.
  </p>
  <p>
    <strong>Funcionamiento:</strong> Reemplaza el valor de cada p√≠xel con la media aritm√©tica
    de los p√≠xeles en su vecindad. El kernel debe estar normalizado (la suma de sus elementos
    es 1) para preservar el brillo global.
  </p>
  <pre><code class="language-python">
# 1. Definici√≥n y Normalizaci√≥n del Kernel (3x3)
kernel_caja = np.ones((3, 3), np.float32)
kernel_normalizado = kernel_caja / 9

# 2. Aplicaci√≥n del Filtro
apple_promediada = cv.filter2D(apple, -1, kernel_normalizado)
  </code></pre>

  <h3>3.4. Filtro Mediano</h3>
  <p>
    Es un filtro <strong>no lineal (estad√≠stico)</strong>, ideal para eliminar el ruido
    <em>Sal y Pimienta</em> (salt-and-pepper noise).
  </p>
  <p>
    <strong>Funcionamiento:</strong> En lugar de calcular un promedio, el p√≠xel central se
    reemplaza con la mediana de todos los valores de intensidad dentro de la ventana del kernel.
    Esto preserva mejor los bordes que el filtro promedio.
  </p>
  <pre><code class="language-python">
# 1. Cargar imagen con ruido S&P (asumimos 'img_noise' est√° cargada)
# img_noise = cv.imread("/ruta/a/images/s&p-noise.jpeg", 0)

# Aplicar el Filtro de Mediana (kernel de 3x3)
img_median = cv.medianBlur(img_noise, 3)
  </code></pre>

  <h3>3.5. Filtro Laplaciano</h3>
  <p>
    Es un filtro de <strong>paso alto</strong> que aproxima la segunda derivada.
    Se utiliza para la detecci√≥n y realce de bordes.
  </p>
  <p>
    <strong>Funcionamiento:</strong> El kernel tiene una suma de pesos igual a cero
    (<code>&sum;K = 0</code>). En regiones uniformes la respuesta es cero; en bordes,
    donde la intensidad cambia r√°pidamente, la respuesta es alta o baja, revelando el contorno.
  </p>
  <pre><code class="language-python">
# 1. Definici√≥n del Kernel Laplaciano de 4-Vecinos
kernel_laplaciano = np.array([[ 0,  1,  0],
                              [ 1, -4,  1],
                              [ 0,  1,  0]], dtype=np.float32)

# 2. Detecci√≥n de Bordes
lena_laplaciana = cv.filter2D(lena_gray, -1, kernel_laplaciano)

# 3. Realce de la Imagen
lena_realzada = lena_gray + lena_laplaciana
  </code></pre>

  <h3>3.6. Gradiente</h3>
  <p>
    El t√©rmino <strong>Gradiente</strong> puede referirse a la primera derivada (como en Sobel o Prewitt),
    pero en este contexto hace referencia al <strong>Gradiente Morfol√≥gico</strong>, un potente detector de contornos.
  </p>
  <p>
    <strong>Funcionamiento (Gradiente Morfol√≥gico):</strong> Se calcula mediante la diferencia entre la
    <em>Dilataci√≥n</em> y la <em>Erosi√≥n</em> de la imagen:
    </p>
  <p style="text-align:center;">
    <code>Gradiente = Dilataci√≥n(I) - Erosi√≥n(I)</code>
  </p>
  <p>
    Esta resta a√≠sla el anillo de p√≠xeles que forman el borde, proporcionando un contorno m√°s robusto.
  </p>
  <pre><code class="language-python">
# Asumimos que 'linux_bin_inv' (imagen binaria) y 'kernel' est√°n definidos.
# Aplicaci√≥n del Gradiente Morfol√≥gico
img_gradiente = cv.morphologyEx(linux_bin_inv, cv.MORPH_GRADIENT, kernel)
  </code></pre>
</section>


    <!-- TEMA 4 -->
<section id="tema4">
  <h3>4. Transformaciones Morfol√≥gicas</h3>
  <p>
    Las transformaciones morfol√≥gicas son operaciones no lineales que modifican la estructura de una imagen bas√°ndose en la forma, utilizando un <strong>Elemento Estructurante (Kernel)</strong>. Se aplican principalmente a im√°genes binarias.
  </p>

  <h3>4.1. Conceptos B√°sicos y Elemento Estructurante</h3>
  <p>
    La Morfolog√≠a se basa en el <strong>Elemento Estructurante</strong> (kernel), que act√∫a como una plantilla o sonda para definir la vecindad de la operaci√≥n.
  </p>
  <p>
    <strong>Funcionamiento:</strong> Se define t√≠picamente como una matriz de unos (<code>np.uint8</code>) y determina la forma y el tama√±o de la vecindad para Erosi√≥n y Dilataci√≥n.
  </p>

  <pre><code># Definici√≥n del Elemento Estructurante (Kernel) de 5x5
kernel = np.ones((5, 5), np.uint8)

# Binarizaci√≥n de una imagen para las operaciones morfol√≥gicas
# Convierte p√≠xeles >= 150 a blanco (255) y el resto a negro (0).
linux_binaria = np.where(linux_gray >= 150, 255, 0).astype(np.uint8)
  </code></pre>

  <h3>4.2. Erosi√≥n y Dilataci√≥n</h3>
  <p>
    Estas son las dos operaciones fundamentales de la Morfolog√≠a Matem√°tica.
  </p>

  <h4>4.2.1. Erosi√≥n (<em>I ‚äñ K</em>)</h4>
  <p>
    <strong>Funcionamiento:</strong> La Erosi√≥n encoge o "adelgaza" las √°reas de primer plano (blancas). Un p√≠xel central se mantiene blanco solo si el kernel completo cae dentro de la regi√≥n blanca de la imagen; de lo contrario, se vuelve negro. Esto elimina peque√±os objetos brillantes y reduce el tama√±o de los objetos.
  </p>

  <pre><code># Aplica Erosi√≥n a la imagen en escala de grises o binaria
img_eroded = cv.erode(linux_gray, kernel, iterations=1)
  </code></pre>

  <h4>4.2.2. Dilataci√≥n (<em>I ‚äï K</em>)</h4>
  <p>
    <strong>Funcionamiento:</strong> La Dilataci√≥n agranda o "engrosa" las √°reas de primer plano (blancas). Un p√≠xel central se vuelve blanco si al menos una parte del kernel coincide con un p√≠xel blanco de la imagen. Esto rellena peque√±os agujeros y une objetos cercanos.
  </p>

  <pre><code># Aplica Dilataci√≥n a la imagen
img_dilated = cv.dilate(linux_gray, kernel, iterations=1)
  </code></pre>

  <h3>4.3. Apertura y Cierre</h3>
  <p>
    Son operaciones compuestas que utilizan <code>cv.morphologyEx</code> para aplicar secuencias de Erosi√≥n y Dilataci√≥n, con prop√≥sitos de limpieza espec√≠ficos.
  </p>

  <h4>4.3.1. Apertura (<em>I ‚àò K</em>)</h4>
  <p>
    <strong>Funcionamiento:</strong> Es la Erosi√≥n seguida de la Dilataci√≥n. Se usa para eliminar el ruido (peque√±os puntos blancos) sin afectar significativamente la forma de los objetos grandes. La erosi√≥n inicial elimina el ruido, y la dilataci√≥n posterior restaura el tama√±o original de los objetos principales.
  </p>

  <pre><code># Apertura: Elimina el ruido blanco (cv.MORPH_OPEN)
img_open = cv.morphologyEx(linux_binaria, cv.MORPH_OPEN, kernel)
  </code></pre>

  <h4>4.3.2. Cierre (<em>I ‚Ä¢ K</em>)</h4>
  <p>
    <strong>Funcionamiento:</strong> Es la Dilataci√≥n seguida de la Erosi√≥n. Se usa para rellenar peque√±os agujeros dentro de los objetos y cerrar brechas o rupturas finas en su contorno.
  </p>

  <pre><code># Cierre: Rellena agujeros (cv.MORPH_CLOSE)
img_close = cv.morphologyEx(linux_binaria, cv.MORPH_CLOSE, kernel)
  </code></pre>

  <h3>4.4. Transformaciones Avanzadas y Extracci√≥n de Bordes</h3>
  <p>
    Estas son transformaciones que se obtienen restando los resultados de operaciones morfol√≥gicas, permitiendo extraer caracter√≠sticas espec√≠ficas de la forma.
  </p>

  <h4>4.4.1. Gradiente Morfol√≥gico (Extracci√≥n de Bordes)</h4>
  <p>
    <strong>Funcionamiento:</strong> Se calcula como la diferencia entre la imagen dilatada y la erosionada (<em>Dilataci√≥n - Erosi√≥n</em>). Su resultado a√≠sla el anillo de p√≠xeles que constituye el contorno del objeto, siendo un detector de bordes muy robusto.
  </p>

  <pre><code># Gradiente Morfol√≥gico: Dilataci√≥n - Erosi√≥n
img_gradiente = cv.morphologyEx(linux_binaria, cv.MORPH_GRADIENT, kernel)

# El notebook morph3.ipynb describe el Borde Externo: Dilataci√≥n - Original
# img_borde_externo = cv.dilate(linux_binaria, kernel) - linux_binaria
  </code></pre>

  <h4>4.4.2. Top Hat y Black Hat (Transformaciones de Realce)</h4>
  <p>
    <strong>Funcionamiento:</strong> Se utilizan para corregir fondos no uniformes o extraer elementos de la imagen que son m√°s peque√±os que el kernel.
  </p>
  <ul>
    <li><strong>Top Hat:</strong> Extrae elementos brillantes peque√±os (<em>Original - Apertura</em>).</li>
    <li><strong>Black Hat:</strong> Extrae elementos oscuros peque√±os (<em>Cierre - Original</em>).</li>
  </ul>

  <pre><code># Top Hat: Realce de elementos brillantes
img_top_hat = cv.morphologyEx(linux_binaria, cv.MORPH_TOPHAT, kernel)

# Black Hat: Realce de elementos oscuros
img_black_hat = cv.morphologyEx(linux_binaria, cv.MORPH_BLACKHAT, kernel)
  </code></pre>
</section>

  </p>
  <p style="text-align:center;">
    <code

 
  </p>
    </section>

    <section id="abstract">
      <h2>4. Abstract (English)</h2>
      <p>[Abstract en ingl√©s para el segundo parcial]</p>
    </section>

    <section id="conclusiones">
      <h2>5. Conclusiones Individuales</h2>
      <p><strong>Integrante 1 (Hannah):</strong> [Conclusi√≥n]</p>
      <p><strong>Integrante 2 (Miguel):</strong> 
        A lo largo de la semana de estudio sobre Procesamiento Digital de Im√°genes, el equipo fortaleci√≥ su comprensi√≥n sobre c√≥mo los sistemas inform√°ticos pueden analizar y transformar im√°genes para obtener informaci√≥n √∫til. Los integrantes coincidieron en que uno de los mayores retos fue dominar el uso de filtros de convoluci√≥n y transformaciones geom√©tricas, ya que implican tanto fundamentos matem√°ticos como su aplicaci√≥n pr√°ctica en entornos de programaci√≥n. Asimismo, el tema de segmentaci√≥n result√≥ especialmente relevante, pues permiti√≥ comprender c√≥mo aislar regiones espec√≠ficas de una imagen y reconocer patrones mediante t√©cnicas de umbralizaci√≥n y detecci√≥n de bordes. En conjunto, el equipo reconoce que este aprendizaje no solo aport√≥ bases te√≥ricas s√≥lidas, sino tambi√©n herramientas aplicables a campos como la visi√≥n por computadora, la inteligencia artificial y la seguridad inform√°tica, √°reas en las que planean aplicar los conocimientos adquiridos.
      </p>
      <p><strong>Integrante 3 (Carol):</strong> Durante este periodo de clases, los temas vistos sobre procesamiento digital de im√°genes me ayudaron a comprender muchas cosas, estre ellas c√≥mo las operaciones matem√°ticas y l√≥gicas permiten modificar, analizar y mejorar im√°genes, algo que opino que es un poco complejo debido a todos los conocimientos que involucra. Aprend√≠ tambien que el filtrado es de gram importancia para cosas como eliminar o resaltar detalles,  identificar los l√≠mites de los objetos, asi tambien las transformaciones que ajustan la forma y estructura de las regiones en una imagen. En conjunto, estos conceptos muestran c√≥mo a partir de principios sencillos como el uso de un kernel se pueden lograr resultados complejos que son la base de muchos sistemas de visi√≥n artificial actuales.</p>
    </section>
  </main>

  <footer>
    <p>¬© 2025 Equipo Panteras Verdes - Reporte Segundo Parcial</p>
  </footer>
</body>
</html>
