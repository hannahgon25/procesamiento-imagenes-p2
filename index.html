<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Reporte Tercer Parcial - Procesamiento de Im√°genes</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>üìã Reporte Tercer Parcial</h1>
    <h2>Procesamiento de Im√°genes</h2>
    <p>Equipo: Panteras Verdes xD</p>

    <details>
      <summary><b>Integrantes</b></summary>
      <ul>
        <li>Gonz√°lez Garc√≠a Hannah Andrea - ID:0276927</li>
        <li>Reza Zatarain Jes√∫s Miguel - ID:0276971</li>
        <li>Guti√©rrez Castellanos Carol Kristel - ID:0276969</li>
      </ul>
</details>
  </header>
  
  <nav>
    <ul>
      <li><a href="#intro"> Introducci√≥n </a></li>
      <li><a href="#tema1">1. Tema 1</a>Binarizaci√≥n, polaridad, umbralizaci√≥n (Carol & Hannah)</li>
      <li><a href="#tema2">2. Tema 2</a></li>
      <li><a href="#tema3">3. Tema 3</a></li>
      <li><a href="#abstract">4. Abstract (English)</a></li>
      <li><a href="#conclusiones">5. Conclusiones</a></li>
    </ul>
  </nav>

  <main>
    <!-- INTRODUCCI√ìN -->
    <section id="intro">
      <h2>1. Introducci√≥n</h2>
      <p>
        En estas √∫ltimas semanas repasamos t√©cnicas de procesamiento de im√°genes: binarizaci√≥n,
        umbralizaci√≥n, morfolog√≠a matem√°tica, extracci√≥n de bordes, an√°lisis de componentes conectados y
        captura de video con OpenCV. El siguiente documento organiza los aportes del equipo y los ejemplos
        de c√≥digo utilizados en pr√°cticas.
      </p>
    </section>

   
    <section id="tema1">
      <h2>1. Tema 1 (Carol & Hannah): Binarizaci√≥n, Polaridad y Umbralizaci√≥n</h2>

  
      <article>
        <h3>Carol ‚Äî Conceptos y flujo pr√°ctico</h3>
        <p>
          En el procesamiento de im√°genes primero preparamos la imagen (suavizado, conversi√≥n a gris) y
          luego aplicamos una estrategia de umbralizaci√≥n adecuada. Despu√©s de binarizar, aplicamos operaciones
          morfol√≥gicas para limpiar la m√°scara antes de extraer informaci√≥n (contornos, componentes).
        </p>

        <h4>Pasos t√≠picos</h4>
        <ol>
          <li>Lectura y conversi√≥n a escala de grises.</li>
          <li>Filtrado (blur, median) para reducir ruido.</li>
          <li>Umbralizaci√≥n (global, Otsu, adaptativa).</li>
          <li>Operaciones morfol√≥gicas para limpiar la m√°scara (erosi√≥n, dilataci√≥n, apertura, cierre).</li>
          <li>Detecci√≥n/extracci√≥n (contornos, connected components).</li>
        </ol>

        <h4>Ejemplo: umbral b√°sico</h4>
        <pre class="code">
_, bin = cv.threshold(gray, 128, 255, cv.THRESH_BINARY)
        </pre>

        <h4>Ejemplo: Otsu (umbral autom√°tico)</h4>
        <pre class="code">
_, bin = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)
        </pre>
      </article>

  
      <article>
        <h3>Hannah ‚Äî Morfolog√≠a Matem√°tica (ampliada)</h3>

        <p>
          La morfolog√≠a matem√°tica aplica operaciones definidas por conjuntos (elementos estructurantes)
          sobre la imagen, interpretada como conjunto de p√≠xeles. Se usa para analizar forma y estructura
          (ej.: eliminaci√≥n de ruido, uni√≥n de regiones, extracci√≥n de bordes).
        </p>

        <h4>Sets (conjuntos)</h4>
        <p>
          En morfolog√≠a, una imagen binaria es un conjunto de p√≠xeles ¬´1¬ª (objeto) y ¬´0¬ª (fondo).
          Las operaciones se definen con un <strong>Elemento Estructurante (SE)</strong>, an√°logo a un kernel.
        </p>

        <h4>Elementos importantes del SE</h4>
        <ul>
          <li><strong>P√≠xeles de primer plano (1)</strong></li>
          <li><strong>P√≠xeles de fondo (0)</strong></li>
          <li><strong>Don't-care (x)</strong> ‚Äî posiciones cuyo valor no importa</li>
        </ul>

        <h4>Operaciones b√°sicas</h4>
        <p><strong>Erosi√≥n:</strong> reduce las regiones blancas (quita bordes / ruido)</p>
        <pre class="code">
erosion = cv.erode(bin, kernel)
        </pre>

        <p><strong>Dilataci√≥n:</strong> expande las regiones blancas (une objetos cercanos)</p>
        <pre class="code">
dilate = cv.dilate(bin, kernel)
        </pre>

        <p><strong>Apertura:</strong> erosi√≥n seguida de dilataci√≥n ‚Äî elimina ruido peque√±o.</p>
        <pre class="code">
opened = cv.morphologyEx(bin, cv.MORPH_OPEN, kernel)
        </pre>

        <p><strong>Cierre:</strong> dilataci√≥n seguida de erosi√≥n ‚Äî rellena huecos peque√±os.</p>
        <pre class="code">
closed = cv.morphologyEx(bin, cv.MORPH_CLOSE, kernel)
        </pre>

        <h4>Aplicaciones compuestas</h4>
        <p><strong>Gradiente morfol√≥gico</strong> (dilataci√≥n - original) para contornos:</p>
        <pre class="code">
grad = cv.dilate(gray, kernel) - gray
        </pre>

        <h4>Esqueletos y thinning</h4>
        <p>Para obtener la ‚Äúl√≠nea central‚Äù de un objeto se usan t√©cnicas de thinning / skeletonization:</p>
        <pre class="code">
skel = cv.ximgproc.thinning(bin)
        </pre>

        <h4>Resumen pr√°ctico</h4>
        <p>
          Use morfolog√≠a justo despu√©s de la binarizaci√≥n para corregir defectos: <em>umbral ‚Üí morfolog√≠a ‚Üí detecci√≥n</em>.
        </p>
      </article>

     

    </section>

    <section id="tema2">
      <h2>2. Tema 2 (Miguel): Operaciones Morfol√≥gicas</h2>
      <p>
        En la Semana XV se trabajaron principalmente operaciones morfol√≥gicas en im√°genes digitales y un cuaderno de pr√°cticas sobre <strong>ccws</strong> (probablemente vinculado a segmentaci√≥n o filtrado). 
        Los temas giran en torno al an√°lisis de estructuras dentro de im√°genes y las transformaciones que permiten resaltar, limpiar o modificar formas.
      </p>

      <h3>1. Operaciones Morfol√≥gicas</h3>
      <ul>
        <li><strong>Definici√≥n:</strong> T√©cnicas basadas en la forma de los objetos dentro de una imagen binaria o en escala de grises.</li>
        <li><strong>Elementos estructurantes:</strong> Figuras (cuadrados, discos, l√≠neas) que sirven como ‚Äúplantillas‚Äù para modificar la imagen.</li>
        <li><strong>Operaciones b√°sicas:</strong>
          <ul>
            <li><strong>Erosi√≥n:</strong> Reduce el tama√±o de los objetos, elimina ruido peque√±o.</li>
            <li><strong>Dilataci√≥n:</strong> Expande los objetos, rellena huecos.</li>
            <li><strong>Apertura:</strong> Erosi√≥n seguida de dilataci√≥n; √∫til para eliminar ruido manteniendo la forma principal.</li>
            <li><strong>Cierre:</strong> Dilataci√≥n seguida de erosi√≥n; rellena huecos peque√±os en los objetos.</li>
          </ul>
        </li>
        <li><strong>Aplicaciones:</strong> Limpieza de im√°genes binarias, extracci√≥n de bordes, segmentaci√≥n de regiones y reconocimiento de patrones estructurales.</li>
      </ul>

      <h3>2. Transformaciones Avanzadas (Morph2.ipynb)</h3>
      <ul>
        <li><strong>Operaciones de borde:</strong> Obtenci√≥n de contornos mediante diferencias entre dilataci√≥n y erosi√≥n.</li>
        <li><strong>Esqueletizaci√≥n:</strong> Reducci√≥n de objetos a su forma m√°s simple (l√≠nea central).</li>
        <li><strong>Reconstrucci√≥n morfol√≥gica:</strong> Recuperaci√≥n de estructuras originales a partir de versiones erosionadas o dilatadas.</li>
        <li><strong>Aplicaciones pr√°cticas:</strong> Detecci√≥n de formas geom√©tricas, procesamiento de texto en im√°genes y an√°lisis de huellas, c√©lulas o estructuras repetitivas.</li>
      </ul>

      <h3>3. Cuaderno CCWS (ccws.ipynb)</h3>
      <p>
        Aunque el nombre no es expl√≠cito, por el contexto de PDI suele relacionarse con:
      </p>
      <ul>
        <li><strong>Segmentaci√≥n de im√°genes:</strong> Separar regiones de inter√©s.</li>
        <li><strong>Filtrado espacial:</strong> Aplicaci√≥n de m√°scaras para suavizar o resaltar detalles.</li>
        <li><strong>Clasificaci√≥n supervisada/no supervisada:</strong> Identificaci√≥n de regiones seg√∫n caracter√≠sticas de color o textura.</li>
        <li><strong>Ejemplo t√≠pico:</strong> Detecci√≥n de √°reas homog√©neas en im√°genes m√©dicas o satelitales.</li>
      </ul>
    </section>

    <section id="tema3">
      <h2>3. Tema 3 (Hannah): An√°lisis de Componentes Conectados y Captura de Video con OpenCV</h2>

      <p>
        Esta secci√≥n muestra c√≥mo pasar de una m√°scara binaria a la extracci√≥n y an√°lisis de regiones (componentes conectados),
        y c√≥mo aplicar todo esto en tiempo real usando captura de video. Est√° dividida para facilitar lectura y aplicaci√≥n pr√°ctica.
      </p>

     
      <article>
        <h3>3.1 Componentes Conectados ‚Äî teor√≠a y uso</h3>
        <p>
          Los <strong>componentes conectados</strong> etiquetan regiones continuas de p√≠xeles con el mismo valor (p. ej. blanco).
          OpenCV ofrece funciones para etiquetar y calcular estad√≠sticas de cada componente.
        </p>

        <h4>Funciones</h4>
        <pre class="code">
# Etiquetado simple
n_labels, labels = cv.connectedComponents(bin)

# Etiquetado con estad√≠sticas
n, lab, stats, centroids = cv.connectedComponentsWithStats(bin)
        </pre>

        <h4>Descripci√≥n de <code>stats</code></h4>
        <ul>
          <li><strong>area</strong> ‚Äî n√∫mero de p√≠xeles</li>
          <li><strong>left, top, width, height</strong> ‚Äî bounding box</li>
          <li><strong>centroid</strong> ‚Äî coordenadas del centro</li>
        </ul>

        <h4>Filtrado por tama√±o (ejemplo)</h4>
        <pre class="code">
for i in range(1, n):  # evitar el label 0 (fondo)
    x = stats[i, cv.CC_STAT_LEFT]
    y = stats[i, cv.CC_STAT_TOP]
    w = stats[i, cv.CC_STAT_WIDTH]
    h = stats[i, cv.CC_STAT_HEIGHT]
    area = stats[i, cv.CC_STAT_AREA]
    if area > 500:
        cv.rectangle(img, (x,y), (x+w, y+h), (0,255,0), 2)
        cv.putText(img, str(i), (x, y-5), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,0), 1)
        </pre>

        <p>
          Con esto se detectan y anotan regiones significativas ‚Äî√∫til para conteo, filtrado y rastreo b√°sico.
        </p>
      </article>

      <!-- Captura de video: secciones explicativas -->
      <article>
        <h3>3.2 Captura de Video con OpenCV ‚Äî secciones</h3>

        <h4>A. Crear el objeto VideoCapture</h4>
        <p>
          El objeto <code>cv.VideoCapture()</code> abre la c√°mara (√≠ndice 0 por defecto) o un archivo de video.
        </p>
        <pre class="code">
cap = cv.VideoCapture(0)  # 0: c√°mara por defecto, o "video.mp4" para archivo
if not cap.isOpened():
    raise Exception("ERROR! No se pudo abrir la c√°mara")
        </pre>

        <h4>B. Lectura de frames y verificaci√≥n</h4>
        <p>
          <code>cap.read()</code> devuelve <code>ret</code> (bool) y <code>frame</code> (imagen). Siempre verificar <code>ret</code>.
        </p>
        <pre class="code">
ret, frame = cap.read()
if not ret:
    break  # fin del video o error
        </pre>

        <h4>C. Visualizaci√≥n en tiempo real</h4>
        <p>
          <code>cv.imshow()</code> muestra la ventana con el frame actual. √ötil combinar con procesamiento previo.
        </p>
        <pre class="code">
cv.imshow("Frame", frame)
        </pre>

        <h4>D. Control del bucle: <code>waitKey</code></h4>
        <p>
          <code>cv.waitKey()</code> permite leer teclas y controlar la velocidad del bucle. Ejemplos de teclas:
        </p>
        <pre class="code">
key = cv.waitKey(17) & 0xFF
if key == ord('q'):   # salir
    break
elif key == ord('g'): # alternar gris
    is_gray = not is_gray
elif key == ord('b'): # alternar blur
    is_blurred = not is_blurred
        </pre>

        <h4>E. Liberar recursos</h4>
        <pre class="code">
cap.release()
cv.destroyAllWindows()
        </pre>

        <h4>F. Ejemplo completo comentado (integrado con procesamiento)</h4>
        <pre class="code">
import cv2 as cv

cap = cv.VideoCapture(0)
if not cap.isOpened():
    raise Exception("ERROR! No se pudo abrir la c√°mara")

is_gray = False
is_blurred = False

while True:
    ret, frame = cap.read()
    if not ret:
        break

    # 1) Pre-procesamiento opcional
    proc = frame.copy()
    if is_gray:
        proc = cv.cvtColor(proc, cv.COLOR_BGR2GRAY)
    if is_blurred:
        proc = cv.blur(proc, (11, 11))

    # 2) Ejemplo: umbralizar y aplicar morfolog√≠a
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) if len(frame.shape) == 3 else frame
    _, bin_mask = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU)
    kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, (5,5))
    clean = cv.morphologyEx(bin_mask, cv.MORPH_OPEN, kernel)

    # 3) Analizar componentes conectados sobre 'clean'
    n, labels, stats, centroids = cv.connectedComponentsWithStats(clean)
    for i in range(1, n):
        area = stats[i, cv.CC_STAT_AREA]
        if area > 500:
            x = stats[i, cv.CC_STAT_LEFT]
            y = stats[i, cv.CC_STAT_TOP]
            w = stats[i, cv.CC_STAT_WIDTH]
            h = stats[i, cv.CC_STAT_HEIGHT]
            cv.rectangle(frame, (x,y), (x+w, y+h), (0,255,0), 2)

    # 4) Mostrar resultado
    cv.imshow("Original", frame)
    cv.imshow("Mask limpia", clean)

    key = cv.waitKey(17) & 0xFF
    if key == ord('q'):
        break
    elif key == ord('g'):
        is_gray = not is_gray
    elif key == ord('b'):
        is_blurred = not is_blurred

cap.release()
cv.destroyAllWindows()
        </pre>

        <p>
          Este ejemplo ilustra el flujo completo: lectura ‚Üí preprocesamiento ‚Üí umbralizaci√≥n ‚Üí morfolog√≠a ‚Üí 
          componentes conectados ‚Üí visualizaci√≥n. Puedes ajustar par√°metros (tama√±o de kernel, umbrales, √°rea m√≠nima)
          seg√∫n el caso de uso.
        </p>
      </article>
    </section>

    <!-- ABSTRACT -->
    <section id="abstract">
      <h2>4. Abstract (English)</h2>
      <p>[ ]</p>
    </section>


<section id="conclusiones">
  <h2>5. Conclusiones Individuales (Tercer Parcial)</h2>

  <p><strong>Integrante 1 (Hannah):</strong> Este parcial ha sido de los mas interesantes ya su vez complejos porque se acercaba el final del semestre. Sin embargo, 
  fue uno de los parciales mas interesentes ya que, pudimos visualisar la aplicaci√≥n practica de temas abordados en parciales anteriores. L o mas divertido para mi fue la cuando me 
  di cuenta de tidas las aplicaciones en contextos reales como lo fue trabajar con video en tiempo real, porque me doy cuenta de como las herramientas y librerias de OpenCV hacen todo su trabajo. 
  Es muy interesante sobre todo en ciberseguridad me parece super valioso estas aplicaciones como el seguimiento de objetos (como el ejemplo de la placa de edomex), el reconocimiento facial o 
  los sistemas de viguilancia. No solo fue interesante la captura de video sino tambi√©n la Morfologia Mstematica porque puede separar objetos o unir partes que deberian estar conectadas. </p>

  <p><strong>Integrante 2 (Miguel):</strong> Al concluir este curso, reconoxco la gran cantidad de conocimientos adquiridos y la relevancia pr√°ctica de
cada tema abordado, a lo largo de las sesiones, comprend√≠ mejor los fundamentos detr√°s de cada transformaci√≥n
aplicada a una imahen y c√≥mo estas tecnicas pueden emplearse en diferentes ambitos y contextos. Lo m√°s 
valioso fue experimentar con herramientas herramientas que permiten mejorar fotograf√≠as, restaurar
imagenes deterioradas o detectar objetos de manera autom√°tica. Esta experiencia me deja una base solida para 
aplicar lo aprendido en proyectos futuros, tanto acad√©micos como profesionales, y me motiva a seguir profundizando
en el area.</p> 
  <p><strong>Integrante 3 (Carol):</strong> Al finalizar este curso de Procesamiento de Im√°genes, 
    me doy cuenta de lo mucho que aprend√≠ y de la utilidad real de cada tema que vimos. Personalmente, 
    agradezco la forma en que el maestro nos iba explicando los temas y conceptos, este curso me ayud√≥ a 
    ver todos los procesos y formulas que hay detras de cada trasformaci√≥n a una im√°gen, entender principalmente 
    como funciona y a partir de eso aplicarlo en nuestra vida, ya sea para mejorar alguna foto, profundizar mas 
    en la parte de restauracion de imagenes o aplicarlo en deteccion de objetos, para mi ha sido de gran 
    importancia e inter√©s. 
   </p>
</section>

</main>

<footer>
  <p>¬© 2025 Equipo Panteras Verdes - Reporte Tercer Parcial</p>
</footer>

</body>
</html>


