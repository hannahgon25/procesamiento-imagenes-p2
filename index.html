<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Reporte Tercer Parcial - Procesamiento de Im√°genes</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1>üìã Reporte Tercer Parcial</h1>
    <h2>Procesamiento de Im√°genes</h2>
    <p>Equipo: Panteras Verdes xD</p>

    <details>
      <summary><b>Integrantes</b></summary>
      <ul>
        <li>Gonz√°lez Garc√≠a Hannah Andrea - ID:0276927</li>
        <li>Reza Zatarain Jes√∫s Miguel - ID:0276971</li>
        <li>Guti√©rrez Castellanos Carol Kristel - ID:0276969</li>
      </ul>
    </details>
  </header>
  
  <nav>
    <ul>
        <li><a href="#intro"> Introducci√≥n </a></li>
      <li><a href="#tema1">1. Tema 1</a>Binarizaci√≥n, polaridad, umbralizaci√≥n</li>
      <li><a href="#tema2">2. Tema 2</a></li>
      <li><a href="#tema3">3. Tema 3</a></li>
      <li><a href="#abstract">4. Abstract (English)</a></li>
      <li><a href="#conclusiones">5. Conclusiones</a></li>
    </ul>
  </nav>

  <main>
 <!-- INTRODUCCI√ìN -->
    <section id="intro">
      <h2>1. Introducci√≥n</h2>

<details>
 <p>
    En estas √∫ltimas semanas realizamos un repaso de conceptos importantes sobre morfolog√≠a matem√°tica y 
    umbralizaci√≥n. Con estos temas de tercer parcial finalizamos este curso, a√±adiendo algunas t√©cnicas ya 
    avanzadas a las que hemos aprendido y que han sido de gran aprendizaje durante el curso.
  </p>
  
  
<section id="tema1">
  <h2>1. Tema 1 (Carol): Binarizaci√≥n, polaridad, umbralizaci√≥n</h2>

  <h3>1. Binarizaci√≥n y Control de Polaridad</h3>
  <p>
    Debemos empezar con preparar la imagen, asegurando que el objeto que nos interese est√© 
    correctamente segmentado para las operaciones morfol√≥gicas.
  </p>

  <h4>A. Binarizaci√≥n </h4>
  <p>
    Consiste en la conversi√≥n de la imagen de escala de grises a un formato binario, valores 0 y 255.<br>
    <strong>Se realiza de la siguiente manera: </strong> Uso de <code>cv.threshold()</code> de OpenCV o de NumPy <code>np.where()</code>.
  </p>

  <h4>B. Inversi√≥n de Polaridad</h4>
  <p>
    Es la t√©cnica para asegurar que el objeto est√© representado en blanco (255) y el fondo en negro (0), o 
    viceversa.<br>
    <strong>Se realiza de la siguiente manera: </strong> Uso del operador <code>~</code> (Bitwise NOT) de NumPy para invertir 
    todos los valores de p√≠xel r√°pidamente. <br>
    <strong>Inversi√≥n: </strong> Utilizaci√≥n de la bandera <code>cv.THRESH_BINARY_INV</code> durante la 
    binarizaci√≥n para lograr la inversi√≥n directamente.
  </p>

  <h3>2. Morfolog√≠a Matem√°tica: Operaciones Fundamentales</h3>
  <p>
    En la Morfolog√≠a Matem√°tica se usa un  <strong>Elemento Estructurante (Kernel)</strong> para modificar la forma de los objetos.
  </p>

  <h4>A. Dilataci√≥n </h4>
  <p>
    Operaci√≥n que expande o agranda las √°reas blancas del objeto.<br>
    <strong>Se realiza de la siguiente manera: </strong> <code>cv.dilate(imagen, kernel)</code>.<br>
    <strong>Aplicaci√≥n:</strong> Fusi√≥n de componentes conexos y relleno de huecos.
  </p>

  <h4>B. Erosi√≥n </h4>
  <p>
    Operaci√≥n que reduce las √°reas blancas del objeto.<br>
    <strong>Se realiza de la siguiente manera: </strong> <code>cv.erode(imagen, kernel)</code>.<br>
    <strong>Aplicaci√≥n:</strong> Eliminaci√≥n de ruido y separaci√≥n de objetos ligeramente unidos.
  </p>

  <h4>C. Aplicaci√≥n Iterativa</h4>
  <p>
    Las operaciones pueden intensificarse utilizando <code>iterations = N</code>, aplicando dilataci√≥n 
    o erosi√≥n m√∫ltiples veces para lograr efectos m√°s marcados.
  </p>

  <h3>3. Aplicaciones Compuestas: Gradiente Morfol√≥gico</h3>

  <h4>A. Gradiente Morfol√≥gico Externo (Detecci√≥n de Contornos)</h4>
  <p>
    T√©cnica utilizada para extraer √∫nicamente el contorno exterior de los objetos.<br>
    <strong>F√≥rmula:</strong><br>
    <code>Borde Externo = Dilataci√≥n(Imagen) ‚Äì Imagen Original</code><br>
    <strong>Efecto:</strong> Se obtiene una l√≠nea delgada representando el contorno externo.
  </p>

  <h4>B. Resta de Im√°genes</h4>
  <p>
    Implementada con el operador <code>-</code> de NumPy, p√≠xel por p√≠xel.
  </p>

  <h3>4. Manipulaci√≥n de Arrays con NumPy</h3>

  <h4>A. Operaciones L√≥gicas</h4>
  <p>
    <code>np.where()</code> es usado tanto para binarizaci√≥n como para aplicar cualquier regla o 
    asignaci√≥n condicional a los p√≠xeles.
  </p>

  <h4>B. Verificaci√≥n de Arrays</h4>
  <p>
    Funciones como <code>np.unique()</code> y <code>.all()</code> permiten verificar la 
    consistencia entre im√°genes, como comprobar si dos resultados son id√©nticos a nivel de p√≠xel.
  </p>

  <h2>2. Umbralizaci√≥n </h2>
  <p>
    La Umbralizaci√≥n es la base de la segmentaci√≥n, y para ello utilizamos distintos m√©todos que var√≠an seg√∫n las condiciones de iluminaci√≥n de la imagen.
  </p>

  <h3>1. Umbralizaci√≥n Global Fija</h3>
  <p>
    Es el m√©todo m√°s b√°sico, donde se selecciona un √∫nico valor de umbral (<strong>T</strong>) que se aplica a todos los p√≠xeles de la imagen por igual. 
    Su implementaci√≥n se realiza utilizando la funci√≥n <code>cv.threshold()</code> de OpenCV o la l√≥gica condicional <code>np.where()</code> de NumPy.
  </p>

  <h3>2. Umbralizaci√≥n Autom√°tica</h3>

  <h4>M√©todo Otsu (<code>cv.THRESH_OTSU</code>)</h4>
  <p>
    Analiza el histograma de la imagen y calcula el umbral √≥ptimo que minimiza la varianza dentro de cada clase, buscando una separaci√≥n clara entre los dos picos principales del histograma.
  </p>

  <h4>M√©todo Triangle (<code>cv.THRESH_TRIANGLE</code>)</h4>
  <p>
    Traza una l√≠nea recta sobre el histograma y selecciona el punto con la mayor distancia a esa l√≠nea. Este m√©todo es especialmente √∫til cuando el histograma est√° dominado por un solo pico grande.
  </p>

  <h3>3. Umbralizaci√≥n Adaptativa</h3>
  <p>
    Es la t√©cnica ideal para im√°genes con iluminaci√≥n irregular. El umbral (<strong>T</strong>) no es √∫nico; en su lugar, se calcula un valor distinto para cada p√≠xel basado en su vecindario local.
    Para implementarlo se utiliza <code>cv.adaptiveThreshold()</code>.
  </p>

  <p><strong>Par√°metros Esenciales:</strong></p>
  <ul>
    <li><strong>M√©todo Adaptativo:</strong> Define c√≥mo se calcula el umbral local (ej. <code>cv.ADAPTIVE_THRESH_MEAN_C</code> basado en el promedio).</li>
    <li><strong>Tama√±o de Bloque:</strong> √Årea local (ej. 21√ó21 p√≠xeles) que se utiliza para calcular el valor del umbral.</li>
    <li><strong>Constante C:</strong> Valor restado al umbral local para ajustar su sensibilidad.</li>
  </ul>

  <p>
    El prop√≥sito principal de este m√©todo es lograr una segmentaci√≥n limpia incluso en im√°genes con sombras o variaciones fuertes de iluminaci√≥n,
    obteniendo as√≠ una base adecuada para aplicar t√©cnicas de Morfolog√≠a Matem√°tica.
  </p>
</section>

</section>


<section id="tema2">
  <h2>2. Tema 2 (Miguel)</h2>
  <p></p>
</section>

<section id="tema3">
  <h2>3. Tema 3 (Hannah)</h2>
  <p></p>
</section>


<section id="abstract">
  <h2>4. Abstract (English)</h2>
  <p>[]</p>
</section>

<section id="conclusiones">
  <h2>5. Conclusiones Individuales (Tercer Parcial)</h2>

  <p><strong>Integrante 1 (Hannah):</strong> []</p>

  <p><strong>Integrante 2 (Miguel):</strong> []</p>

  <p><strong>Integrante 3 (Carol):</strong> []</p>
</section>

</main>

<footer>
  <p>¬© 2025 Equipo Panteras Verdes - Reporte Tercer Parcial</p>
</footer>

</body>
</html>


