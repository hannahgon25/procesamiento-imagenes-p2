<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Reporte Segundo Parcial - Procesamiento de Im谩genes</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <h1> Reporte Segundo Parcial</h1>
    <h2>Procesamiento de Im谩genes</h2>
    <p>Equipo: Panteras Verdes xD</p>
    
    <!-- Apartado desplegable -->
    <details>
      <summary><b>Integrantes</b></summary>
      <ul>
        <li>Gonz谩lez Garc铆a Hannah Andrea - ID:0276927</li>
        <li>Reza Zatarain Jes煤s Miguel - ID:0276971</li>
        <li>Guti茅rrez Castellanos Carol Kristel - ID:0276969</li>
      </ul>
    </details>
  </header>
  
  <nav>
    <ul>
      <li><a href="#tema1">1. Histogramas, Espacios de Color e introducci贸n a filtrado</a></li>
      <li><a href="#tema2">2. Procesamiento Digital de Im谩genes</a></li>
      <li><a href="#tema3">3. Filtrado y Morfolog铆a Matem谩tica</a></li>
      <li><a href="#abstract">4. Abstract (English)</a></li>
      <li><a href="#conclusiones">5. Conclusiones</a></li>
    </ul>
  </nav>

  <main>
<!-- TEMA 1 -->
<section id="tema1">
  <h2>1. Procesamiento de Histogramas,  Transformaci贸n a Espacios de Color e introducci贸n a filtrado [Hannah]</h2>

  <h3>1.1 Procesamiento de Histogramas</h3>
  <p>
    El procesamiento de histogramas es una t茅cnica fundamental en el an谩lisis digital de im谩genes,
    ya que permite estudiar la distribuci贸n de intensidades de una imagen. El histograma muestra la
    frecuencia de aparici贸n de cada nivel de gris o componente de color, y es 煤til para tareas como
    la mejora del contraste, la detecci贸n de bordes o la segmentaci贸n de regiones.
  </p>

  <p>
    En Python, el histograma puede obtenerse utilizando bibliotecas como <code>OpenCV</code> y
    <code>Matplotlib</code>. El siguiente ejemplo muestra c贸mo calcular y graficar el histograma de
    una imagen en escala de grises:
  </p>

  <pre><code class="language-python">
import cv2
import matplotlib.pyplot as plt

# Cargar imagen y convertir a escala de grises
img = cv2.imread('imagen.jpg', cv2.IMREAD_GRAYSCALE)

# Calcular histograma
hist = cv2.calcHist([img], [0], None, [256], [0, 256])

# Mostrar imagen e histograma
plt.figure(figsize=(10,4))
plt.subplot(1,2,1), plt.imshow(img, cmap='gray'), plt.title('Imagen Original')
plt.subplot(1,2,2), plt.plot(hist, color='black'), plt.title('Histograma de Intensidades')
plt.show()
  </code></pre>

  <p>
    Este tipo de an谩lisis permite identificar si una imagen est谩 subexpuesta, sobreexpuesta o bien
    distribuida en t茅rminos de intensidad. Adem谩s, sirve como base para aplicar t茅cnicas de
    ecualizaci贸n.
  </p>

  <h3>1.2 Transformaci贸n a Espacios de Color (YCbCr, HSV, etc.)</h3>
  <p>
    La transformaci贸n de una imagen desde el espacio de color RGB hacia otros espacios como YCbCr o
    HSV es esencial para separar informaci贸n de luminancia y crominancia, facilitando operaciones
    como la detecci贸n de color, la segmentaci贸n o el ajuste de brillo y saturaci贸n.
  </p>

  <p>
    En el espacio <strong>YCbCr</strong>, el componente <em>Y</em> representa la luminancia (brillo),
    mientras que <em>Cb</em> y <em>Cr</em> representan las diferencias de color (azul y rojo,
    respectivamente). En cambio, en el espacio <strong>HSV</strong>, los componentes son
    <em>Hue</em> (tono), <em>Saturation</em> (saturaci贸n) y <em>Value</em> (valor o brillo).
  </p>

  <pre><code class="language-python">
# Transformaci贸n de RGB a YCbCr y HSV
img_color = cv2.imread('imagen.jpg')

# Conversi贸n a diferentes espacios de color
img_ycbcr = cv2.cvtColor(img_color, cv2.COLOR_BGR2YCrCb)
img_hsv = cv2.cvtColor(img_color, cv2.COLOR_BGR2HSV)

# Visualizaci贸n de componentes individuales
y, cb, cr = cv2.split(img_ycbcr)
h, s, v = cv2.split(img_hsv)

# Mostrar resultados
titles = ['Canal Y', 'Canal Cb', 'Canal Cr']
for i, channel in enumerate([y, cb, cr]):
    plt.subplot(1,3,i+1)
    plt.imshow(channel, cmap='gray')
    plt.title(titles[i])
plt.show()
  </code></pre>

  <p>
    Estas transformaciones permiten manipular de manera independiente el brillo o el color, lo cual
    resulta 煤til para el procesamiento selectivo de im谩genes, como en la detecci贸n de tonos de piel
    o el an谩lisis de objetos espec铆ficos por su color caracter铆stico.
  </p>

  <h3>1.3 Ecualizaci贸n del Histograma</h3>
  <p>
    La ecualizaci贸n del histograma busca mejorar el contraste de una imagen redistribuyendo los
    niveles de intensidad para que se utilice todo el rango disponible. Esta t茅cnica resalta detalles
    en zonas oscuras o claras y mejora la percepci贸n visual.
  </p>

  <pre><code class="language-python">
# Ecualizaci贸n global del histograma
img_eq = cv2.equalizeHist(img)

# Mostrar resultados
plt.figure(figsize=(10,4))
plt.subplot(1,2,1), plt.imshow(img, cmap='gray'), plt.title('Original')
plt.subplot(1,2,2), plt.imshow(img_eq, cmap='gray'), plt.title('Ecualizada')
plt.show()
  </code></pre>

  <p>
    El resultado es una imagen con mayor contraste y una distribuci贸n de intensidades m谩s uniforme.
    Sin embargo, en im谩genes con iluminaci贸n variable, la ecualizaci贸n global puede producir artefactos
    o exagerar el ruido.
  </p>

  <h3>1.4 Ecualizaci贸n Local (CLAHE)</h3>
  <p>
    Para evitar los problemas de la ecualizaci贸n global, se utiliza la <strong>ecualizaci贸n local</strong>,
    tambi茅n conocida como <em>CLAHE</em>. Esta t茅cnica
    divide la imagen en peque帽as regiones (<em>tiles</em>) y aplica ecualizaci贸n individualmente, limitando
    el contraste excesivo.
  </p>

  <pre><code class="language-python">
# Ecualizaci贸n local adaptativa (CLAHE)
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
img_clahe = clahe.apply(img)

# Mostrar comparaci贸n
plt.figure(figsize=(10,4))
plt.subplot(1,2,1), plt.imshow(img_eq, cmap='gray'), plt.title('Ecualizaci贸n Global')
plt.subplot(1,2,2), plt.imshow(img_clahe, cmap='gray'), plt.title('Ecualizaci贸n Local (CLAHE)')
plt.show()
  </code></pre>

  <p>
    Este m茅todo es especialmente eficaz en im谩genes con iluminaci贸n desigual o en aplicaciones m茅dicas
    y satelitales, donde se requiere preservar los detalles locales sin generar sobrecontraste.
  </p>
  <h3>1.3 Introducci贸n a filtrado</h3>
  <p>A continuaci贸n se presenta un enlace a una pizarra de cambas para entendender mejor como funciona el codigo o filtrado de una imagen, con cada iteriaci贸n</p>
  <p>Visualizaci贸n interactiva disponible en <a href="https://www.canva.com/design/DAG0kH3DdSY/kdreVo4REGddZAz1BWAjaA/edit?utm_content=DAG0kH3DdSY&utm_campaign=designshare&utm_medium=link2&utm_source=sharebutton">este enlace de Canvas</a>.</p>


  <h3>Conclusi贸n del Tema</h3>
  <p>
    En resumen, el procesamiento de histogramas y las transformaciones de color son herramientas
    esenciales para la mejora y an谩lisis de im谩genes digitales. Mientras la ecualizaci贸n global permite
    mejorar el contraste general, la ecualizaci贸n local ofrece resultados m谩s equilibrados en regiones
    con diferentes condiciones de iluminaci贸n. Las transformaciones a espacios de color como YCbCr y HSV
    ampl铆an las posibilidades de an谩lisis al separar la informaci贸n de luminancia y crominancia.
  </p>
</section>


    <!-- TEMA 2 -->
    <section id="tema2">
      <h2>2. Procesamiento Digital de Im谩genes (Miguel)</h2>
      <p>
        En esta secci贸n se abordaron los fundamentos del procesamiento digital de im谩genes (PDI), comenzando con la adquisici贸n y digitalizaci贸n de im谩genes, donde se explic贸 c贸mo una imagen anal贸gica se convierte en formato digital mediante sensores que capturan la informaci贸n luminosa y la transforman en una matriz num茅rica. Se revisaron los conceptos de muestreo espacial y de intensidad, esenciales para representar correctamente los detalles de la imagen.
      </p>
      <p>
        Posteriormente, se analiz贸 la representaci贸n y almacenamiento de im谩genes, entendiendo que cada imagen se compone de una matriz de p铆xeles cuyos valores determinan su intensidad o color. Se discuti贸 la importancia de la resoluci贸n, la profundidad de bits y los formatos m谩s comunes como BMP, PNG y JPG, destacando sus ventajas seg煤n el uso y el nivel de compresi贸n requerido.
      </p>
      <p>
        En cuanto a las operaciones puntuales y de contraste, se exploraron t茅cnicas que modifican directamente la intensidad de los p铆xeles, tales como la ecualizaci贸n de histograma, el ajuste de brillo y contraste, y la normalizaci贸n, las cuales permiten mejorar la apariencia visual o resaltar detalles relevantes de la imagen.
      </p>
      <p>
        Tambi茅n se presentaron los filtros espaciales y la convoluci贸n, herramientas esenciales para el procesamiento local de p铆xeles. Se revisaron filtros lineales (como el promedio y el gaussiano) y no lineales (como el de mediana), aplicados al suavizado, la detecci贸n de bordes y la eliminaci贸n de ruido. Adem谩s, se explic贸 el papel de las m谩scaras y el operador de convoluci贸n en la manipulaci贸n de la imagen.
      </p>
      <p>
        En el tema de transformaciones geom茅tricas, se describieron procesos como la traslaci贸n, rotaci贸n y escalado de im谩genes, los cuales modifican la posici贸n y orientaci贸n de los p铆xeles mediante coordenadas homog茅neas y transformaciones matriciales.
      </p>
      <p>
        M谩s adelante, se abord贸 la segmentaci贸n y el an谩lisis morfol贸gico, que incluyen m茅todos para dividir una imagen en regiones significativas utilizando t茅cnicas de umbralizaci贸n, detecci贸n de contornos y operaciones morfol贸gicas como la dilataci贸n, erosi贸n, apertura y cierre, 煤tiles en el reconocimiento de objetos y an谩lisis estructural.
      </p>
      <p>
        Finalmente, se exploraron diversas aplicaciones del PDI, mostrando c贸mo estos conceptos se emplean en 谩reas como la visi贸n por computadora, el an谩lisis m茅dico y los sistemas de seguridad, demostrando el impacto y la versatilidad del procesamiento digital de im谩genes en la actualidad.
      </p>
    </section>

   
    <section id="tema3">
      <h2>3. Filtrado y Morfolog铆a Matem谩tica (Carol)</h2>
      <p>


  <h3>I. Fundamentos, Configuraci贸n y Manipulaci贸n Num茅rica</h3>

  <p>
   
  <h3>3. Filtrado y Detecci贸n de Bordes en PDI</h3>
  <p>
    Esta secci贸n cubre las t茅cnicas mas importantes de manipulaci贸n de vecindades (filtrado)
    utilizadas para suavizar im谩genes, eliminar ruido y resaltar bordes.
  </p>

  <h3>3.1. Kernels / Elementos Estructurantes</h3>
  <p>
    Un <strong>kernel</strong> es una matriz peque帽a que define la vecindad de p铆xeles
    que influir谩 en el valor del p铆xel central. La disposici贸n y los valores de sus elementos
    determinan la operaci贸n de filtrado las cuales son: suavizado, detecci贸n de bordes, entre otros.
  </p>
  <p>
    <strong>Funcionamiento:</strong> Se definen como arrays de NumPy con el tipo de dato necesario
    (normalmente <code>np.float32</code>) para convoluci贸n. Los valores internos representan
    la cantidad aplicada a los p铆xeles vecinos.
  </p>
  <pre><code class="language-python">
# Kernel para Filtro Promedio (caja 3x3 sin normalizar)
kernel_caja = np.ones((3, 3), np.float32)

# Kernel para Filtro Laplaciano (ejemplo de 4-vecinos)
kernel_laplaciano = np.array([[ 0,  1,  0],
                              [ 1, -4,  1],
                              [ 0,  1,  0]], dtype=np.float32)
  </code></pre>

  <h3>3.2. Convoluci贸n y Correlaci贸n</h3>
  <p>
    La <strong>convoluci贸n</strong> es la operaci贸n fundamental del filtrado lineal.
    Para esto se tiene que voltear el kernel 180掳 y calcular la suma del producto del kernel
    con los p铆xeles de la vecindad. En codigo se aplica mediante la funci贸n <code>cv.filter2D()</code>.
  </p>
  <pre><code class="language-python">
# Se asume que 'kernel_normalizado' ya est谩 definido (ej. kernel_caja / 9)
apple_filtrada = cv.filter2D(apple, -1, kernel_normalizado)
  </code></pre>

  <h3>3.3. Filtro de Caja</h3>
  <p>
    Es un filtro que realiza la operaci贸n de suavizado.
    Su principal efecto es la atenuaci贸n del ruido de alta frecuencia y los detalles finos.
  </p>
  <p>
    <strong>Funcionamiento:</strong> Reemplaza el valor de cada p铆xel con la media aritm茅tica
    de los p铆xeles en su vecindad. El kernel debe estar normalizado (la suma de sus elementos
    es 1) para preservar el brillo general.
  </p>
  <pre><code class="language-python">
# 1. Definici贸n y Normalizaci贸n del Kernel (3x3)
kernel_caja = np.ones((3, 3), np.float32)
kernel_normalizado = kernel_caja / 9

# 2. Aplicaci贸n del Filtro
apple_promediada = cv.filter2D(apple, -1, kernel_normalizado)
  </code></pre>

  <h3>3.4. Filtro de Mediana</h3>
  <p>
    Es un filtro <strong>no lineal</strong>, que sirve para eliminar el ruido
    <em>Sal y Pimienta</em> (salt-and-pepper noise).
  </p>
  <p>
    <strong>Funcionamiento:</strong> En lugar de calcular un promedio, el p铆xel central se
    reemplaza con la mediana de todos los valores de intensidad dentro de la ventana del kernel.
    Esto preserva mejor los bordes que el filtro de caja.
  </p>
  <pre><code class="language-python">
# 1. Cargar imagen con ruido S&P (asumimos 'img_noise' est谩 cargada)
# img_noise = cv.imread("/ruta/a/images/s&p-noise.jpeg", 0)

# Aplicar el Filtro de Mediana (kernel de 3x3)
img_median = cv.medianBlur(img_noise, 3)
  </code></pre>

  <h3>3.5. Filtro Laplaciano</h3>
  <p>
    Es un filtro de <strong>paso alto</strong> que aproxima la segunda derivada.
    Se utiliza para la detecci贸n y realce de bordes.
  </p>
  <p>
    <strong>Funcionamiento:</strong> El kernel tiene una suma de pesos igual a cero
    (<code>&sum;K = 0</code>). En regiones uniformes la respuesta es cero; en bordes,
    donde la intensidad cambia r谩pidamente, la respuesta es alta o baja, de esta manera revelando el contorno.
  </p>
  <pre><code class="language-python">
# 1. Definici贸n del Kernel Laplaciano de 4-Vecinos
kernel_laplaciano = np.array([[ 0,  1,  0],
                              [ 1, -4,  1],
                              [ 0,  1,  0]], dtype=np.float32)

# 2. Detecci贸n de Bordes
lena_laplaciana = cv.filter2D(lena_gray, -1, kernel_laplaciano)

# 3. Realce de la Imagen
lena_realzada = lena_gray + lena_laplaciana
  </code></pre>

  <h3>3.6. Gradiente</h3>
  <p>
    El t茅rmino <strong>Gradiente</strong> hace referencia al <strong>Gradiente Morfol贸gico</strong>,
    un detector de contornos de gran potencia.
  </p>
  <p>
    <strong>Funcionamiento (Gradiente Morfol贸gico):</strong> Se calcula mediante la diferencia entre la
    <em>Dilataci贸n</em> y la <em>Erosi贸n</em> de una imagen:
    </p>
  <p style="text-align:center;">
    <code>Gradiente = Dilataci贸n- Erosi贸n</code>
  </p>
  <p>
    Esta resta a铆sla el anillo de p铆xeles que forman el borde, proporcionando un contorno m谩s fuerte.
  </p>
  <pre><code class="language-python">
# Asumimos que la 'imagen binaria' y 'kernel' est谩n definidos.
# Aplicaci贸n del Gradiente Morfol贸gico
img_gradiente = cv.morphologyEx(linux_bin_inv, cv.MORPH_GRADIENT, kernel)
  </code></pre>
</section>

<section id="tema4">
  <h3>4. Transformaciones Morfol贸gicas</h3>
  <p>
    Las transformaciones morfol贸gicas son operaciones no lineales que modifican la estructura de una imagen 
    bas谩ndose en la forma, utilizando un <strong>Elemento Estructurante (Kernel)</strong>. 
    Se aplican principalmente a im谩genes binarias.
  </p>

  <h3>4.1. Conceptos B谩sicos y Elemento Estructurante</h3>
  <p>
    La Morfolog铆a se basa en el <strong>Elemento Estructurante</strong> (kernel), que act煤a como una plantilla
    para definir la vecindad de la operaci贸n.
  </p>
  <p>
    <strong>Funcionamiento:</strong> Se define comunmente como una matriz de unos (<code>np.uint8</code>) y
    determina la forma y el tama帽o de la vecindad para Erosi贸n y Dilataci贸n.
  </p>

  <pre><code># Definici贸n del Elemento Estructurante (Kernel) de 5x5
kernel = np.ones((5, 5), np.uint8)

# Binarizaci贸n de una imagen para las operaciones morfol贸gicas
# Convierte p铆xeles >= 150 a blanco (255) y el resto a negro (0).
linux_binaria = np.where(linux_gray >= 150, 255, 0).astype(np.uint8)
  </code></pre>

  <h3>4.2. Erosi贸n y Dilataci贸n</h3>
  <p>
    Estas son las dos operaciones fundamentales de la Morfolog铆a Matem谩tica.
  </p>

  <h4>4.2.1. Erosi贸n</h4>
  <p>
    <strong>Funcionamiento:</strong> La Erosi贸n adelgaza las 谩reas de primer plano (blancas).
    Un p铆xel central se mantiene blanco solo si el kernel completo cae dentro de la regi贸n blanca de la imagen;
    de lo contrario, se vuelve negro. Esto elimina peque帽os objetos brillantes y reduce el tama帽o de los objetos.
  </p>

  <pre><code># Aplica Erosi贸n a la imagen en escala de grises o binaria
img_eroded = cv.erode(linux_gray, kernel, iterations=1)
  </code></pre>

  <h4>4.2.2. Dilataci贸n</h4>
  <p>
    <strong>Funcionamiento:</strong> La Dilataci贸n agranda o engrosa las 谩reas de primer plano (blancas).
    Un p铆xel central se vuelve blanco si al menos una parte del kernel coincide con un p铆xel blanco de la imagen. 
    Esto rellena peque帽os agujeros y une objetos cercanos.
  </p>

  <pre><code># Aplica Dilataci贸n a la imagen
img_dilated = cv.dilate(linux_gray, kernel, iterations=1)
  </code></pre>

  <h3>4.3. Apertura y Cierre</h3>
  <p>
    Son operaciones compuestas que utilizan <code>cv.morphologyEx</code> para aplicar secuencias de Erosi贸n y Dilataci贸n,
    con prop贸sitos de limpieza en areas espec铆ficas.
  </p>

  <h4>4.3.1. Apertura</h4>
  <p>
    <strong>Funcionamiento:</strong> Es la Erosi贸n seguida de la Dilataci贸n. Se usa para eliminar el 
    ruido (peque帽os puntos blancos) sin afectar significativamente la forma de los objetos grandes. 
    La erosi贸n inicial elimina el ruido, y la dilataci贸n posterior restaura el tama帽o original de los objetos principales.
  </p> 

  <pre><code># Apertura: Elimina el ruido blanco (cv.MORPH_OPEN)
img_open = cv.morphologyEx(linux_binaria, cv.MORPH_OPEN, kernel)
  </code></pre>

  <h4>4.3.2. Cierre</h4>
  <p>
    <strong>Funcionamiento:</strong> Es la Dilataci贸n seguida de la Erosi贸n. Se usa para rellenar peque帽os agujeros
    dentro de los objetos y cerrar brechas o rupturas finas en su contorno.
  </p>

  <pre><code># Cierre: Rellena agujeros (cv.MORPH_CLOSE)
img_close = cv.morphologyEx(linux_binaria, cv.MORPH_CLOSE, kernel)
  </code></pre>

  <h3>4.4. Transformaciones Avanzadas y Extracci贸n de Bordes</h3>
  <p>
    Estas son transformaciones que se obtienen restando los resultados de operaciones morfol贸gicas,
    permitiendo extraer caracter铆sticas espec铆ficas de la forma.
  </p>

  <h4>4.4.1. Extracci贸n de Bordes</h4>
  <p>
    <strong>Funcionamiento:</strong> Se calcula como la diferencia entre la imagen dilatada y la erosionada
    (<em>Dilataci贸n - Erosi贸n</em>). Su resultado a铆sla el anillo de p铆xeles que constituye el contorno del objeto,
    detectando asi los bordes.
  </p>

  <pre><code># Gradiente Morfol贸gico: Dilataci贸n - Erosi贸n
img_gradiente = cv.morphologyEx(linux_binaria, cv.MORPH_GRADIENT, kernel)

# El notebook morph3.ipynb describe el Borde Externo: Dilataci贸n - Original
# img_borde_externo = cv.dilate(linux_binaria, kernel) - linux_binaria
  </code></pre>

  <h4>4.4.2. Top Hat y Black Hat (Transformaciones de Realce)</h4>
  <p>
    <strong>Funcionamiento:</strong> Se utilizan para corregir fondos no uniformes o extraer elementos de la 
    imagen que son m谩s peque帽os que el kernel.
  </p>
  <ul>
    <li><strong>Top Hat:</strong> Extrae elementos brillantes peque帽os (<em>Original - Apertura</em>).</li>
    <li><strong>Black Hat:</strong> Extrae elementos oscuros peque帽os (<em>Cierre - Original</em>).</li>
  </ul>

  <pre><code># Top Hat: Realce de elementos brillantes
img_top_hat = cv.morphologyEx(linux_binaria, cv.MORPH_TOPHAT, kernel)

# Black Hat: Realce de elementos oscuros
img_black_hat = cv.morphologyEx(linux_binaria, cv.MORPH_BLACKHAT, kernel)
  </code></pre>
</section>

  </p>
  <p style="text-align:center;">
    <code

 
  </p>
    </section>

    <section id="abstract">
      <h2>4. Abstract (English)(Miguel)</h2>
      <p>[Abstract en ingl茅s para el segundo parcial]</p>
    </section>

    <section id="conclusiones">
      <h2>5. Conclusiones Individuales</h2>
      <p><strong>Integrante 1 (Hannah):</strong>Para los temas vistos de este segundo parcial, me ha permitido comprender de mejor forma los cambios y transformaci贸nes que 
      se pueden llevar a cabo en una imagen y su comportamineto como fue, la visualizacion de los histogramas de una imagen a color. Fue muy interezante y enrriquesedor los aprendizajes
    ,los temas y el desarrollo de expociones que llevamos a caboo que nos hizo comprender mas a fondo y de forma m谩s particular un tema. Para nuestro equipo nos toco el YCbCr donde vimos la separacion de
      la luminacia y los espacios de color. Es de hecho muy interesante como se aplican los fdiferentes espacios de color en la vida diari. En el caso de el YCbCr , a mi me parcedi muy interesante ela transmicion de la image a las pantallas televisoras,
      la deteccion de rostros. Entre muchas cosas el desarrollo de los temas de este parcial me ha paricido mas claro y significativo y es muy interesante comprender esos cambios que ocurren cuando uno cambia el filtro cuando se toma una foto. Lo vemos muy normal pero es todo un desarrollo. </p>
      <p><strong>Integrante 2 (Miguel):</strong> 
        A lo largo de la semana de estudio sobre Procesamiento Digital de Im谩genes, el equipo fortaleci贸 su comprensi贸n sobre c贸mo los sistemas inform谩ticos pueden analizar y transformar im谩genes para obtener informaci贸n 煤til. Los integrantes coincidieron en que uno de los mayores retos fue dominar el uso de filtros de convoluci贸n y transformaciones geom茅tricas, ya que implican tanto fundamentos matem谩ticos como su aplicaci贸n pr谩ctica en entornos de programaci贸n. Asimismo, el tema de segmentaci贸n result贸 especialmente relevante, pues permiti贸 comprender c贸mo aislar regiones espec铆ficas de una imagen y reconocer patrones mediante t茅cnicas de umbralizaci贸n y detecci贸n de bordes. En conjunto, el equipo reconoce que este aprendizaje no solo aport贸 bases te贸ricas s贸lidas, sino tambi茅n herramientas aplicables a campos como la visi贸n por computadora, la inteligencia artificial y la seguridad inform谩tica, 谩reas en las que planean aplicar los conocimientos adquiridos.
      </p>
      <p><strong>Integrante 3 (Carol):</strong> Durante este periodo de clases, los temas vistos sobre procesamiento de 
        im谩genes me ayudaron a comprender muchas cosas, estre ellas c贸mo las operaciones matem谩ticas y 
        l贸gicas permiten modificar, analizar y mejorar im谩genes, algo que opino que es un poco complicado debido a todos 
        los conocimientos que involucra. Aprend铆 tambien que el filtrado es de gran importancia para cosas como eliminar 
        o resaltar detalles,  identificar los l铆mites de los objetos, asi tambien las transformaciones que ajustan la 
        forma y estructura de las regiones en una imagen, es importante saber como podemos recuperar imagenes o ver 
        detalles que a simple vista no puede verse, lo mejor es que todo esto son procesos, formulas que solo necesitan aplicarse.
        Con estos conceptos podemos ver c贸mo a partir de principios sencillos como el uso de un kernel se pueden 
        lograr resultados complejos que son la base de muchos sistemas de im谩genes actuales.</p>
    </section>
  </main>

  <footer>
    <p>漏 2025 Equipo Panteras Verdes - Reporte Segundo Parcial</p>
  </footer>
</body>
</html>
